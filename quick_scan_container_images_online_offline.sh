#!/bin/bash

set -o pipefail

preflight_image_scan_result_csv="preflight_image_scan_result.csv"
python_script_file="csv_to_xlsx_converter.py"

print_help() {
    cat <<EOF
------------------------------------------------------------------------------------------------------------------------
Usage (API-based):
    $0 -rn <repo_ns> -cp <cnf_prefix> [-t <tag_type>] -d <auth.json> -at <api_token> -fq <fqdn> [-ft <filter>]
    
      -rn | --repo-ns
            The repository namespace: either an organization or a user name 
            (e.g., "avareg_5gc" or "avu0").
      
      -cp | --cnf-prefix
            The CNF image prefix to search for. This can be a specific prefix (e.g., "global-amf-rnic")
            or a wildcard/multiple prefixes separated by a pipe character (e.g., "global|non-global").
      
      -t | --tag-type (Optional)
            The image tag type: "name" to use the image tag, or "digest" to use the manifest digest.
            If omitted, the default is "name".
      
      -d | --auth-json
            The path to the Docker authentication JSON file (e.g., auth.json).
            If container image does not need docker auth, then it's optional.
      
      -at | --api-token
            The API token (Bearer Token) generated by the Registry Server Admin.
      
      -fq | --fqdn
            The fully-qualified domain name of your private registry (e.g., quay.io).
      
      -ft | --filter (Optional)
            A filter to exclude certain images. For example, use "existed_image|tested_image"
            to filter out images containing these strings.

Usage (Offline):
    $0 --img <image_list.txt> -d <auth.json> -fq <fqdn>
    
      --img | --img-file
            A text file containing a list of images to scan (one image per line).
      
      The other options are the same as described above.

Additional Examples:
    Example 1 (API-based):
      $0 -rn ava -cp "global-|specific" -d auth.json -at xxxxxx -fq quay.io -t name -ft "existed_image|tested_image"
      
    Example 2 (API-based with defaults):
      $0 -rn avareg_5gc -cp global- -d auth.json -at xxxxxx -fq quay.io
      
    Example 3 (Offline):
      Private-Registry:
      $0 --img image_list.txt -d auth.json -fq quay.io
      
      Public-Registry:
      $0 --img image_list.txt -fq quay.io

Note:
    - Both "tag-type" and "log-type" (if used) are optional.
    - Ensure that all required files (like the authentication JSON) exist and are accessible.
------------------------------------------------------------------------------------------------------------------------
EOF
    exit 0
}


for i in "$@"; do
    case $i in
    -rn | --repo-ns)
        if [ -n "$2" ]; then
            REPO_NS="$2"
            shift 2
            continue
        fi
        ;;
    -img | --img-file)
        if [ -n "$2" ]; then
            IMG_FILE="$2"
            shift 2
            continue
        fi
        ;;
    -cp | --cnf-prefix)
        if [ -n "$2" ]; then
            CNF_PREFIX="$2"
            shift 2
            continue
        fi
        ;;
    -t | --tag-type)
        if [ -n "$2" ]; then
            TAG_TYPE="$2"
            shift 2
            continue
        fi
        ;;
    -fq | --fqdn)
        if [ -n "$2" ]; then
            FQDN="$2"
            shift 2
            continue
        fi
        ;;
    -d | --auth-json)
        if [ -n "$2" ]; then
            AUTH_JSON="$2"
            shift 2
            continue
        fi
        ;;
    -at | --api-token)
        if [ -n "$2" ]; then
            API_TOKEN="$2"
            shift 2
            continue
        fi
        ;;
    -ft | --filter)
        if [ -n "$2" ]; then
            FILTER="$2"
            shift 2
            continue
        fi
        ;;
    -h | -\? | --help)
        print_help
        shift #
        ;;
    *)
        # unknown option
        ;;
    esac
done
if [[ -z "$API_TOKEN" ]]; then
      if [[ "$IMG_FILE" == "" || "$FQDN" == "" ]]; then
           echo "Usage: bash $0 -img image_list.txt -fq quay.io -d auth.json"
           exit 0
      fi
      echo "API_TOKEN is not defined then you are using ${IMG_FILE} file!!"
      # Skip all the checks below
else
    #Note: tag-type and log-type can be excluded from argument#
    if [[ "$REPO_NS" == "" || "$FQDN" == "" || "$API_TOKEN" == "" || "$AUTH_JSON" == "" ]]; then
        print_help
    fi

    if [[ "$TAG_TYPE" == "" ]]; then
        TAG_TYPE="name"
    fi

    #if filter arg is empty, then we will filter chartrepo
    if [[ "$FILTER" == "" ]]; then
        FILTER="chartrepo"
    fi

fi

#check if requirement files are existed
file_exists() {
    [ -z "${1-}" ] && bye Usage: file_exists name.
    ls "$1" >/dev/null 2>&1
}
# Prints all parameters and exits with the error code.
bye() {
    log "$*"
    exit 1
}

# Prints all parameters to stdout, prepends with a timestamp.
log() {
    printf '%s %s\n' "$(date +"%Y%m%d-%H:%M:%S")" "$*"
}

rename_file() {
    # Check if the filename argument is provided
    if [ -z "$1" ]; then
        log "Usage: rename_file old_filename new_filename"
        return 1
    fi

    # Check if the file exists
    if [ ! -f "$1" ]; then
        log "Error: file '$1' does not exist" >/dev/null 2>&1
        return 1
    fi

    # Check if the new filename argument is provided
    if [ -z "$2" ]; then
        log "Usage: rename_file old_filename new_filename"
        return 1
    fi

    # Rename the file
    mv "$1" "$2"
    log "File '$1' has been renamed to '$2'" >/dev/null 2>&1
    return 0
}

check_tools() {
    if file_exists "$(which python3)" && file_exists "$(which preflight)"; then
        printf "%-48s \e[1;32m%-24s\e[m\n" "python3 and preflight installed" "OK"
    else
        printf "%-48s \e[1;31m%-24s\e[m\n" "python3 and preflight installed" "NOK"
        exit 1
    fi

    # Check if the bc utility is installed
    if file_exists "$(which bc)"; then
        printf "%-48s \e[1;32m%-24s\e[m\n" "bc utility installed" "OK"
    else
        printf "%-48s \e[1;31m%-24s\e[m\n" "bc utility installed" "NOK"
        exit 1
    fi

    file_exists "${python_script_file}" || bye "${python_script_file} No such file."
}

check_preflight_version() {
    # Set the minimum Preflight version required
    MIN_PREFLIGHT_VERSION="1.6.11"

    # Check if Preflight is installed and get the version
    PREFLIGHT_VERSION=$(preflight --version | grep -o -E '[0-9]+\.[0-9]+\.[0-9]+')

    # Compare the Preflight version to the minimum version required
    if [ "$(printf '%s\n' "$MIN_PREFLIGHT_VERSION" "$PREFLIGHT_VERSION" | sort -V | head -n1)" != "$MIN_PREFLIGHT_VERSION" ]; then
        printf "%-48s \e[1;31m%-24s\e[m\n" "Check Preflight Minimum version 1.6.11+" "NOK"
        exit 1
    else
        printf "%-48s \e[1;32m%-24s\e[m\n" "Check Preflight Minimum version 1.6.11+" "OK"
    fi
}
#Check if python pandas and openpyxl packages are installed
check_python_packages() {
    if pip3 show pandas &>/dev/null && pip3 show openpyxl &>/dev/null; then
        #log "pandas and openpyxl are installed"
        printf "%-48s \e[1;32m%-24s\e[m\n" "Python Pandas and Openpyxl installed" "OK"
        return 1
    elif pip3 show pandas &>/dev/null; then
        #log "pandas is installed, but openpyxl is not" && bye "openpyxl is not installed!"
        printf "%-48s \e[1;31m%-24s\e[m\n" "Python Openpyxl" "NOK"
        exit 1
    elif pip3 show openpyxl &>/dev/null; then
        #log "openpyxl is installed, but pandas is not" && bye "pandas is not installed!"
        printf "%-48s \e[1;31m%-24s\e[m\n" "Python Pandas" "NOK"
        exit 1
    else
        #log "pandas and openpyxl are not installed" && bye "both pandas and openpyxl are not installed!"
        printf "%-48s \e[1;31m%-24s\e[m\n" "Python Pandas and Openpyxl" "NOK"
        exit 1
    fi
}

check_registry_server_connection() {
    HOST="$1"
    #GOOGLE="${2:-google.com}"
    
    if [[ -z "$API_TOKEN" ]]; then
         HOST="$FQDN"
    fi

    if command -v nc >/dev/null 2>&1; then
        if nc -zv4 "$HOST" 80 >/dev/null 2>&1; then
            printf "%-48s \e[1;32m%-24s\e[m\n" "$HOST's Connection" "OK"
        else
            printf "%-48s \e[1;31m%-24s\e[m\n" "$HOST's Connection" "NOK"
            exit 1
        fi
    else
        printf "%-48s \e[1;33m%-24s\e[m\n" "$HOST's Connection" "SKIPPED"
    fi
}

check_docker_auth_json_connection() {
    HOST=$1
    
    if [[ -z "$API_TOKEN" ]]; then
         HOST="$FQDN"
    fi

    cat "$AUTH_JSON" | grep $HOST >/dev/null 2>&1
    if [ $? -eq 0 ]; then
        #log "Check Docker Authentication to $HOST succeeded!"
        printf "%-48s \e[1;32m%-24s\e[m\n" "Docker Authentication" "OK"
    else
        #log "Check Docker Authentication to $HOST failed!"
        printf "%-48s \e[1;31m%-24s\e[m\n" "Docker Authentication" "NOK"
        exit 1
    fi
}

check_private_registry_server_auth() {
    HOST=$1

    status_url="https://${HOST}/api/v1/repository?namespace=${REPO_NS}"
    status_code=$(curl -I --silent -o /dev/null -w "%{http_code}" -X GET -H "Authorization: Bearer ${API_TOKEN}" "${status_url}")
    if [ $status_code = "200" ]; then # succeed checking authenatication using Bear API_TOKEN
        #log "Check Private Registry Server to $HOST succeeded"
        printf "%-48s \e[1;32m%-24s\e[m\n" "Registry Server Bearer-Token Access" "OK"
    else
        #log "Check Private Registry Server to $HOST is FAILED, please check your Bear Token manually!"
        printf "%-48s \e[1;31m%-24s\e[m\n" "Registry Server Bearer-Token Access" "NOK"
        exit 1
    fi
}

start_convert_csv_xlsx_format_sort() {
    input_csv=$1
    output_xlsx=$2

    if [ ! -f "$input_csv" ]; then
        log "Input file $input_csv does not exist!"
        exit 1
    fi

    python3 "${python_script_file}" "$input_csv" "$output_xlsx"
    if [ $? -eq 0 ]; then
        log "Successfully Converted from $input_csv to $output_xlsx!"
    else
        log "Failed to Convert from $input_csv to $output_xlsx!!!"
        exit 1
    fi
}

start_container_images_scan() {
    # Preflight ENV settings
    export PFLT_JUNIT="true"
    export PFLT_LOGLEVEL=debug
    export PFLT_LOGFILE=/tmp/preflight.log

    printf "%s\n" "Please be patient while scanning images..."
    count=0
    total_seconds=0
    scan_error=0  # flag to track any failure

    for ((j = 0; j < ${#ImageLists[*]}; j++)); do
        start_time=$(date +%s.%N)
        
        unset hasModFilesMap
        declare -A hasModFilesMap
        
        hasModStatus=""
        hasModFiles=""

        if [[ -z "$API_TOKEN" ]]; then
            image_details="${ImageLists[$j]}"
            repo_imgname_tag=$(echo "$image_details" | cut -d'/' -f2-)
            img_name=$(echo "$image_details" | rev | cut -d '/' -f1 | rev | cut -d':' -f1)
            inspect_url="$image_details"
        else
            image_url="https://${FQDN}/api/v1/repository/${REPO_NS}/${ImageLists[$j]}"
            if [[ "${TAG_TYPE}" == "name" ]]; then
                tag_type_flag=".name + \":\" + .tags[].name"
            else
                tag_type_flag=".name + \"@\" + .tags[].manifest_digest"
            fi
            image_details=$(curl --silent -X GET -H "Authorization: Bearer ${API_TOKEN}" "${image_url}" | jq -r "$tag_type_flag" | head -n1)
            tag=$(echo "$image_details" | cut -d ':' -f2)
            inspect_url="${FQDN}/${REPO_NS}/${ImageLists[$j]}:$tag"
            img_name=$(echo "${ImageLists[$j]}" | rev | cut -d '/' -f1 | rev)
            repo_imgname_tag="$img_name:$tag"
        fi

        printf "\n%s\n" "Scanning the following image: ${repo_imgname_tag}"
        printf "%s\n" "================================================================================"        

        # Run preflight and capture its exit code using pipefail and PIPESTATUS
        result_output=$(preflight check container "$inspect_url" ${AUTH_JSON:+-d "$AUTH_JSON"} 2>&1 \
               | awk 'match($0, /check=([^ ]+)/, c) && match($0, /result=([^ ]+)/, r) {print c[1] "," r[1]}')
        preflight_exit_status=${PIPESTATUS[0]}

        if [ $preflight_exit_status -ne 0 ]; then
            log "Preflight scan failed for image: $inspect_url"
            scan_error=1
            # Optionally, you can choose to exit immediately:
            # return 1
            continue
        fi

        printf "%-26s %-26s %-10s\n" "Image Name" "Test Case" "Status"
        printf "%s\n" "-------------------------------------------------------------"

        console_output=($(printf "%s\n" "$result_output" | awk -v img="$img_name" '{print img "," $0}'))

        for line in "${console_output[@]}"; do
            image=$(printf "%s\n" "$line" | awk -F',' '{print $1}')
            testcase=$(printf "%s\n" "$line" | awk -F',' '{print $2}')
            status=$(printf "%s\n" "$line" | awk -F',' '{print $3}')

            if [ "$hasModStatus" = "FAILED" ]; then
                hasModFiles="${hasModFilesMap[$testcase]}"
            else
                hasModFiles=""
            fi
            if [[ "$testcase" != "HasModifiedFiles" ]]; then
                 hasModFiles=""
            fi

            if [ "$status" = "FAILED" ]; then
                printf "%-20s %-28s \e[1;31m%-14s\e[m\n" "${image}" "${testcase}" "${status}"
            elif [ "$status" = "PASSED" ]; then
                printf "%-20s %-28s \e[1;32m%-14s\e[m\n" "${image}" "${testcase}" "${status}"
            else
                printf "%-20s %-28s \e[1;33m%-14s\e[m\n" "${image}" "${testcase}" "NOT_APP"
            fi

            if [[ "$testcase" = "HasModifiedFiles" && "$status" = "FAILED" ]]; then
                if [ -n "${hasModFilesMap[$testcase]}" ]; then
                    hasModFilesMap[$testcase]+="$(cat /tmp/preflight.log | grep -o 'file=[^ ]*' | cut -d= -f2 | tr '\n' ':' | sed 's/:$//')"
                else
                    hasModFilesMap[$testcase]="$(cat /tmp/preflight.log | grep -o 'file=[^ ]*' | cut -d= -f2 | tr '\n' ':' | sed 's/:$//')"
                fi
                hasModStatus="FAILED"
            fi
        done

        for line in "${console_output[@]}"; do
            image=$(printf "%s\n" "$line" | awk -F',' '{print $1}')
            testcase=$(printf "%s\n" "$line" | awk -F',' '{print $2}')
            status=$(printf "%s\n" "$line" | awk -F',' '{print $3}' | sed 's/ERROR/NOT_APP/g')
            if [ "$hasModStatus" = "FAILED" ]; then
                hasModFiles="${hasModFilesMap[$testcase]}"
            else
                hasModFiles=""
            fi

            printf "%s,%s,%s,%s,%s\n" "${image}" "${tag}" "${hasModFiles}" "${testcase}" "${status}"
        done >> "$preflight_image_scan_result_csv"

        verdict_status=$(cat /tmp/preflight.log | awk 'match($0, /result: ([^"]+)/, r) {print "Verdict: " r[1]}')
        vstatus=$(echo "$verdict_status" | awk '{print $2}')
        if [[ "$vstatus" =~ "FAILED" ]]; then
            printf "Verdict: \e[1;31m%-10s\e[m\n" "${vstatus}"
        elif [[ "$vstatus" =~ "PASSED" ]]; then
            printf "Verdict: \e[1;32m%-10s\e[m\n" "${vstatus}"
        else
            printf "Verdict: \e[1;33m%-10s\e[m\n" "NOT_APP"
        fi

        touch /tmp/preflight.log

        end_time=$(date +%s.%N)
        printf "Time elapsed: %.3f seconds\n" "$(echo "$end_time - $start_time" | bc)"
        elapsed_time=$(echo "$end_time - $start_time" | bc)
        total_seconds=$(echo "$total_seconds + $elapsed_time" | bc)
        count=$((count + 1))
    done

    printf "%s\n" "--------------------------------------------------------------"
    total_time=$(date -u -d "@$total_seconds" '+%Hh:%Mm:%Ss')
    printf "Total Number Images Scanned: %s\n" "$count"
    printf "Total Time Scanned: %s\n" "$total_time"
    printf "%s\n" "------------------------------------------------------"

    # Return failure if any preflight scan failed
    if [ "$scan_error" -ne 0 ]; then
        return 1
    else
        return 0
    fi
}

# Define the function to check and add an extra empty line
check_and_add_empty_line() {
    local file_to_check="$1"

    # Check if the last line of the file is empty
    if [ -n "$(tail -c 1 "$file_to_check")" ]; then
        # If not, add an extra empty line
        echo >> "$file_to_check"
        #echo "Added an extra empty line to $file_to_check"
    fi
}


###############################Main Function###################################
printf "\n%s\n" "Checking the pre-requirements steps..........."
printf "%s\n" "========================================================"
printf "%-46s %-10s\n" "Pre-Requirements Checking" "Status"
printf "%s\n" "---------------------------------------------------------"
#check preflight and python3 exist
check_tools

#check preflight minimum version 1.6.11+
check_preflight_version

#check registry server is reachable
check_registry_server_connection $FQDN

#Check Private Registry Server authentication
if [[ -n "$API_TOKEN" ]]; then
     check_private_registry_server_auth $FQDN
fi

#Check python pandas and openpyxl packages are installed
check_python_packages

#check docker authentication to private registry server has been login
#check_docker_auth_json_connection $FQDN

printf "%s\n" "======================================================="

if [[ -z "$API_TOKEN" ]]; then
    # Define the array
    ImageLists=()

    # Define the file to check
    file_to_check="${IMG_FILE}"

    # Call the function to check and add an extra empty line
    check_and_add_empty_line "$file_to_check"

    # Read each line from image_list.txt and add it to the array
    while IFS= read -r line; do
    if [ -n "$line" ]; then
        ImageLists+=("$line")
        echo $line
    fi
    done < "${IMG_FILE}"
else
    #Get all images based user's criteria and filters from QAUY via REST API#
    #some cases where new images are not responded via REST API then add an exception here
    new_images=('ava-core/univ-nf-ava' 'ava-core/univ-nf-alex')
    if [[ -z "$CNF_PREFIX" ]]; then
        ImageLists=("${new_images[@]}")
    else
        #some cases where new images are not responded via REST API then add an exception here
        readarray -t _ImageLists <<<$(curl --silent -X GET -H "Authorization: Bearer ${API_TOKEN}" "https://${FQDN}/api/v1/repository?namespace=${REPO_NS}" | jq -r '.repositories[].name' | egrep ${CNF_PREFIX} | egrep -v ${FILTER})
            #ImageLists=("${_ImageLists[@]}")
        # Combined Online-list with WA-List then comment out below line
        ImageLists=("${_ImageLists[@]}" "${new_images[@]}")
    fi
fi

if [ -z $ImageLists ]; then
    log "There is no image in the array list"
    log "Please check with curl cmd manually to see if this image responded to REST API or not!!!"
    exit 1
fi


#check if exist csv is existed and rename it
rename_file $preflight_image_scan_result_csv "${preflight_image_scan_result_csv}_saved"

#Print header for CSV
printf "%s\n" "Image Name,Image Tag,Has Modified Files,Test Case,Status" | tee $preflight_image_scan_result_csv >/dev/null

# Start preflight scan to check the container images
if start_container_images_scan; then
    start_convert_csv_xlsx_format_sort "$preflight_image_scan_result_csv" "images_scan_results.xlsx"
else
    log "Container images scan failed; skipping CSV conversion."
    exit 1
fi
